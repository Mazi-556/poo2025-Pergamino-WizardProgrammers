Estructura de arquitectura hexagonal resumida:

ğŸ“‚ ar.edu.unnoba.poo2025.torneos
â”‚
â”œâ”€â”€ ğŸ“¦ domain                 <-- EL CORAZÃ“N (Aislado)
â”‚   â”œâ”€â”€ ğŸ“‚ model              (Tus clases puras: Participant, Tournament...)
â”‚   â””â”€â”€ ğŸ“‚ ports
â”‚       â”œâ”€â”€ ğŸ“‚ in             (Interfaces de Casos de Uso)
â”‚       â””â”€â”€ ğŸ“‚ out            (Interfaces de Repositorios)
â”‚
â”œâ”€â”€ ğŸ“¦ application            <-- EL CEREBRO (Orquestador)
â”‚   â””â”€â”€ ğŸ“‚ usecase            (La lÃ³gica de los servicios: implementan ports.in)
â”‚
â””â”€â”€ ğŸ“¦ infrastructure         <-- EL CUERPO (Detalles tÃ©cnicos)
    â”œâ”€â”€ ğŸ“‚ adapter
    â”‚   â”œâ”€â”€ ğŸ“‚ in             (Controladores Web, Chatbot)
    â”‚   â””â”€â”€ ğŸ“‚ out            (ImplementaciÃ³n JPA, MongoDB, Emails)
    â””â”€â”€ ğŸ“‚ config             (Configuraciones de Beans de Spring)



La misma estructura, pero mas detallada:

ğŸ“‚ ar.edu.unnoba.poo2025.torneos
â”œâ”€â”€ ğŸ“¦ domain                  <-- EL NÃšCLEO (Solo Java puro, 0 anotaciones)
â”‚   â”œâ”€â”€ ğŸ“‚ model
â”‚   â”‚   â””â”€â”€ Tournament.java         (POJO limpio: solo atributos y lÃ³gica)
â”‚   â””â”€â”€ ğŸ“‚ ports
â”‚       â”œâ”€â”€ ğŸ“‚ in                   (QuÃ© puede hacer el usuario)
â”‚       â”‚   â””â”€â”€ ManageTournamentUseCase.java
â”‚       â””â”€â”€ ğŸ“‚ out                  (QuÃ© necesita el dominio guardar)
â”‚           â””â”€â”€ TournamentRepositoryPort.java
â”‚
â”œâ”€â”€ ğŸ“¦ application             <-- LOS CASOS DE USO (Orquestadores)
â”‚   â””â”€â”€ ğŸ“‚ usecase
â”‚       â””â”€â”€ ManageTournamentService.java (Implementa la lÃ³gica sin saber de DB)
â”‚
â””â”€â”€ ğŸ“¦ infrastructure          <-- EL MUNDO REAL (Frameworks y Adaptadores)
    â”œâ”€â”€ ğŸ“‚ adapter
    â”‚   â”œâ”€â”€ ğŸ“‚ in              (Entrada: QuiÃ©n usa la app)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“‚ web
    â”‚   â”‚   â”‚   â””â”€â”€ TournamentController.java  (Tu antiguo Resource, API REST)
    â”‚   â”‚   â””â”€â”€ ğŸ“‚ chat
    â”‚   â”‚       â””â”€â”€ WhatsappChatAdapter.java(por ejemplo si quisieramos poner un chatbot)
    â”‚   â”‚
    â”‚   â””â”€â”€ ğŸ“‚ out             (Salida: AdÃ³nde van los datos)
    â”‚       â”œâ”€â”€ ğŸ“‚ persistence
    â”‚       â”‚   â”œâ”€â”€ ğŸ“‚ jpa     (Tu actual PostgreSQL)
    â”‚       â”‚   â”‚   â”œâ”€â”€ JpaTournamentAdapter.java
    â”‚       â”‚   â”‚   â””â”€â”€ mapper/TournamentEntity.java (AquÃ­ pones @Entity)
    â”‚       â”‚   â””â”€â”€ ğŸ“‚ mongo   (Tu futuro MongoDB)
    â”‚       â”‚       â””â”€â”€ MongoTournamentAdapter.java
    â”‚       â””â”€â”€ ğŸ“‚ notification
    â”‚           â””â”€â”€ EmailAdapter.java
    â”‚
    â””â”€â”€ ğŸ“‚ config              (ConfiguraciÃ³n de Spring, Swagger, etc.)



    FLUJO DE COMUNICACION (Cortesia de Gemini):


### 1. Capa de DOMINIO (El CorazÃ³n)

AquÃ­ no hay nada de Spring. Solo Java puro.

**El Modelo (`domain/model/Task.java`):**


public class Task {
    private Long id;
    private String description;
    // Constructor, getters y setters
}



**El Puerto de Salida (`domain/ports/out/TaskRepositoryPort.java`):**
*(Es la interfaz que dice: "necesito guardar tareas")*


public interface TaskRepositoryPort {
    Task save(Task task);
}



El Puerto de Entrada (`domain/ports/in/CreateTaskUseCase.java`):
(Es la interfaz que dice: "esta es la acciÃ³n que el mundo puede pedirme")

public interface CreateTaskUseCase {
    void create(String description);
}


### 2. Capa de APLICACIÃ“N (El Cerebro)

AquÃ­ se implementa la lÃ³gica. **Nota:** No usa la base de datos, usa el **Puerto**.

El Caso de Uso (`application/usecase/CreateTaskService.java`):

public class CreateTaskService implements CreateTaskUseCase {
    private final TaskRepositoryPort repositoryPort; // Inyectamos la interfaz (puerto)

    public CreateTaskService(TaskRepositoryPort repositoryPort) {
        this.repositoryPort = repositoryPort;
    }

    @Override
    public void create(String description) {
        Task newTask = new Task();
        newTask.setDescription(description);
        
        // AquÃ­ podrÃ­as poner lÃ³gica: "Si la descripciÃ³n es corta, dar error"
        repositoryPort.save(newTask); // Se lo manda al puerto, no sabe quÃ© DB hay
    }
}



### 3. Capa de INFRAESTRUCTURA (Los Adaptadores)

AquÃ­ es donde conectamos con el mundo real (Spring, JPA, etc.).

Adaptador de Entrada (Web - `infrastructure/adapter/in/web/TaskController.java`):

@RestController
@RequestMapping("/tasks")
public class TaskController {
    private final CreateTaskUseCase createTaskUseCase; // Usa la interfaz de entrada

    public TaskController(CreateTaskUseCase createTaskUseCase) {
        this.createTaskUseCase = createTaskUseCase;
    }

    @PostMapping
    public void postTask(@RequestBody String desc) {
        createTaskUseCase.create(desc); // El controlador solo "pasa la bola"
    }
}


**Adaptador de Salida (Base de Datos - `infrastructure/adapter/out/persistence/JpaTaskAdapter.java`):

@Component
public class JpaTaskAdapter implements TaskRepositoryPort {
    private final JpaTaskRepository jpaRepo; // El repo de Spring Data JPA

    public JpaTaskAdapter(JpaTaskRepository jpaRepo) {
        this.jpaRepo = jpaRepo;
    }

    @Override
    public Task save(Task task) {
        // 1. Convertimos el objeto Dominio a una Entidad de DB (@Entity)
        TaskEntity entity = new TaskEntity(task.getDescription());
        // 2. Guardamos fÃ­sicamente
        TaskEntity saved = jpaRepo.save(entity);
        // 3. Devolvemos el objeto Dominio de nuevo
        return new Task(saved.getId(), saved.getDescription());
    }
}

